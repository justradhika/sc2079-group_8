This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
algo/
  lib/
    car.py
    controller.py
    path.py
    pathfinding.py
  server/
    server.py
  config.py
  sim.py
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="algo/lib/car.py">
import math
from enum import Enum
from dataclasses import dataclass

class CarAction(Enum):
    """Actions the car can perform."""
    FORWARD = "forward"
    BACKWARD = "backward"
    TURN_LEFT = "turn_left"
    TURN_RIGHT = "turn_right"
    STOP = "stop"


@dataclass
class CarState:
    x: float  # cm from bottom-left corner
    y: float  # cm from bottom-left corner
    theta: float  # orientation in radians (0 = facing east)

    def distance_to(self, other: 'CarState') -> float:
        return math.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)

    def angle_to(self, other: 'CarState') -> float:
        return math.atan2(other.y - self.y, other.x - self.x)


@dataclass
class CarCommand:
    action: CarAction
    parameters: dict
    expected_end_state: CarState

def normalize_angle(angle: float) -> float:
    """Normalize angle to [-π, π] range."""
    while angle > math.pi:
        angle -= 2 * math.pi
    while angle < -math.pi:
        angle += 2 * math.pi
    return angle


def angle_difference(angle1: float, angle2: float) -> float:
    """Shortest angular difference between two angles."""
    diff = angle2 - angle1
    return normalize_angle(diff)
</file>

<file path="algo/lib/controller.py">
"""
Fixed Dubins-aware controller that follows curve geometry without bugs.
"""

import math
from typing import List, Optional, Dict, Any, Tuple
from dataclasses import dataclass
from enum import Enum

from lib.car import CarState, CarAction, CarCommand, normalize_angle, angle_difference
from config import config
from lib.path import DubinsPath, DubinsPathType
from lib.pathfinding import CarPathPlanner

class DubinsSegmentType(Enum):
    LEFT_TURN = "L"
    RIGHT_TURN = "R"
    STRAIGHT = "S"

@dataclass
class DubinsSegmentInfo:
    """Information about current position within a Dubins path segment."""
    segment_type: DubinsSegmentType
    segment_index: int  # 0, 1, or 2 for the three parts of a Dubins path
    start_point: Tuple[float, float]
    end_point: Tuple[float, float]
    start_heading: float
    end_heading: float
    center_point: Optional[Tuple[float, float]] = None  # For arc segments

@dataclass
class CarStatus:
    """Current status of the car including position uncertainty."""
    estimated_state: CarState
    confidence_radius: float
    last_command: Optional[CarCommand] = None
    commands_executed: int = 0


class DubinsAwareController:
    """Controller that follows Dubins path geometry with proper arc movement."""

    def __init__(self):
        self.waypoint_tolerance = config.pathfinding.waypoint_tolerance
        self.angle_tolerance = config.pathfinding.angle_tolerance
        self.max_forward_step = config.pathfinding.max_forward_step
        self.turning_radius = config.car.turning_radius

        # Path following state
        self.current_path: Optional[List[DubinsPath]] = None
        self.path_index: int = 0
        self.current_segment: Optional[DubinsSegmentInfo] = None
        self.image_recognition_time: int = 0
        self.at_target: bool = False

    def set_path(self, path_segments: List[DubinsPath]):
        """Set the path for the car to follow."""
        self.current_path = path_segments
        self.path_index = 0
        self.current_segment = None
        self.image_recognition_time = 0
        self.at_target = False

        print(f"Controller: Set path with {len(path_segments)} Dubins segments")
        for i, segment in enumerate(path_segments):
            print(f"  Path {i}: {segment.path_type.value} ({segment.length:.1f}cm)")

    def get_next_command(self, car_status: CarStatus) -> Optional[CarCommand]:
        """Generate next command by following Dubins curve geometry."""
        if not self.current_path:
            return CarCommand(CarAction.STOP, {"reason": "no_path"}, car_status.estimated_state)

        if self.path_index >= len(self.current_path):
            print(f"Mission complete! Visited all {len(self.current_path)} targets.")
            return CarCommand(CarAction.STOP, {"reason": "path_complete"}, car_status.estimated_state)

        current_dubins_path = self.current_path[self.path_index]
        current_state = car_status.estimated_state

        # Initialize first segment if needed
        if self.current_segment is None:
            self.current_segment = self._initialize_first_segment(current_dubins_path)
            if self.current_segment is None:
                print(f"Error: Failed to initialize segment for path {self.path_index}")
                self.path_index += 1
                return self.get_next_command(car_status)

        # Check if at end of entire Dubins path (image recognition)
        if self._is_at_dubins_path_end(current_state, current_dubins_path):
            if not self.at_target:
                self.at_target = True
                self.image_recognition_time = 30
                print(f"At target {self.path_index + 1}/{len(self.current_path)}. Starting image recognition.")

            if self.image_recognition_time > 0:
                self.image_recognition_time -= 1
                return CarCommand(
                    CarAction.STOP,
                    {"reason": "image_recognition", "frames_remaining": self.image_recognition_time},
                    current_state
                )
            else:
                # Move to next Dubins path
                print(f"Image recognition complete for target {self.path_index + 1}")
                self.path_index += 1
                self.current_segment = None
                self.at_target = False
                return self.get_next_command(car_status)

        # Check if current segment is complete
        if self._is_current_segment_complete(current_state):
            next_segment = self._get_next_segment(current_dubins_path)
            if next_segment is None:
                # No more segments in this path, but not at final target
                # This indicates we're close to the end, continue to end check
                pass
            else:
                self.current_segment = next_segment
                print(f"Advanced to segment {self.current_segment.segment_index} ({self.current_segment.segment_type.value})")

        # Generate movement command
        return self._generate_dubins_command(current_state)

    def _initialize_first_segment(self, dubins_path: DubinsPath) -> Optional[DubinsSegmentInfo]:
        """Initialize the first segment of a Dubins path."""
        path_type = dubins_path.path_type.value.lower()
        waypoints = dubins_path.waypoints

        if len(waypoints) < 2 or len(path_type) < 1:
            print(f"Error: Invalid path data - waypoints: {len(waypoints)}, type: '{path_type}'")
            return None

        segment_char = path_type[0].upper()
        try:
            segment_type = DubinsSegmentType(segment_char)
        except ValueError:
            print(f"Error: Invalid segment type '{segment_char}' from path type '{path_type}'")
            return None

        start_point = waypoints[0]
        end_point = waypoints[1]
        start_heading = dubins_path.start_state.theta

        # Calculate end heading
        if segment_type == DubinsSegmentType.STRAIGHT:
            end_heading = math.atan2(end_point[1] - start_point[1], end_point[0] - start_point[0])
        else:
            center = self._calculate_turn_center(start_point, start_heading, segment_type)
            end_heading = self._calculate_heading_at_point(end_point, center, segment_type)

        segment_info = DubinsSegmentInfo(
            segment_type=segment_type,
            segment_index=0,
            start_point=start_point,
            end_point=end_point,
            start_heading=start_heading,
            end_heading=end_heading
        )

        if segment_type != DubinsSegmentType.STRAIGHT:
            segment_info.center_point = self._calculate_turn_center(start_point, start_heading, segment_type)

        return segment_info

    def _calculate_turn_center(self, point: Tuple[float, float], heading: float, turn_type: DubinsSegmentType) -> Tuple[float, float]:
        """Calculate the center of the turning circle."""
        x, y = point

        if turn_type == DubinsSegmentType.LEFT_TURN:
            center_x = x - self.turning_radius * math.sin(heading)
            center_y = y + self.turning_radius * math.cos(heading)
        else:  # RIGHT_TURN
            center_x = x + self.turning_radius * math.sin(heading)
            center_y = y - self.turning_radius * math.cos(heading)

        return (center_x, center_y)

    def _calculate_heading_at_point(self, point: Tuple[float, float], center: Tuple[float, float], turn_type: DubinsSegmentType) -> float:
        """Calculate the heading at a point on a turn arc."""
        px, py = point
        cx, cy = center

        dx, dy = px - cx, py - cy

        if turn_type == DubinsSegmentType.LEFT_TURN:
            heading = math.atan2(dx, -dy)
        else:  # RIGHT_TURN
            heading = math.atan2(-dx, dy)

        return normalize_angle(heading)

    def _is_current_segment_complete(self, current_state: CarState) -> bool:
        """Check if the current segment is complete."""
        if not self.current_segment:
            return True

        end_x, end_y = self.current_segment.end_point
        distance = math.sqrt((current_state.x - end_x)**2 + (current_state.y - end_y)**2)

        if self.current_segment.segment_type != DubinsSegmentType.STRAIGHT:
            angle_diff = abs(angle_difference(current_state.theta, self.current_segment.end_heading))
            return distance <= self.waypoint_tolerance and angle_diff <= self.angle_tolerance
        else:
            return distance <= self.waypoint_tolerance

    def _is_at_dubins_path_end(self, current_state: CarState, dubins_path: DubinsPath) -> bool:
        """Check if we're at the end of the entire Dubins path."""
        end_state = dubins_path.end_state
        distance = math.sqrt(
            (current_state.x - end_state.x)**2 +
            (current_state.y - end_state.y)**2
        )
        angle_diff = abs(angle_difference(current_state.theta, end_state.theta))

        return distance <= self.waypoint_tolerance and angle_diff <= self.angle_tolerance

    def _get_next_segment(self, dubins_path: DubinsPath) -> Optional[DubinsSegmentInfo]:
        """Get the next segment in the Dubins path."""
        if not self.current_segment or self.current_segment.segment_index >= 2:
            return None  # Already at last segment

        path_type = dubins_path.path_type.value.lower()
        next_index = self.current_segment.segment_index + 1
        waypoints = dubins_path.waypoints

        if next_index >= len(path_type) or next_index + 1 >= len(waypoints):
            return None

        segment_char = path_type[next_index].upper()
        segment_type = DubinsSegmentType(segment_char)

        start_point = waypoints[next_index]
        end_point = waypoints[next_index + 1]
        start_heading = self.current_segment.end_heading

        if segment_type == DubinsSegmentType.STRAIGHT:
            end_heading = math.atan2(end_point[1] - start_point[1], end_point[0] - start_point[0])
        else:
            center = self._calculate_turn_center(start_point, start_heading, segment_type)
            end_heading = self._calculate_heading_at_point(end_point, center, segment_type)

        segment_info = DubinsSegmentInfo(
            segment_type=segment_type,
            segment_index=next_index,
            start_point=start_point,
            end_point=end_point,
            start_heading=start_heading,
            end_heading=end_heading
        )

        if segment_type != DubinsSegmentType.STRAIGHT:
            segment_info.center_point = self._calculate_turn_center(start_point, start_heading, segment_type)

        return segment_info

    def _generate_dubins_command(self, current_state: CarState) -> CarCommand:
        """Generate command appropriate for the current Dubins segment."""
        if not self.current_segment:
            return CarCommand(CarAction.STOP, {"reason": "no_segment"}, current_state)

        if self.current_segment.segment_type == DubinsSegmentType.STRAIGHT:
            return self._generate_straight_command(current_state)
        else:
            return self._generate_arc_command(current_state)

    def _generate_straight_command(self, current_state: CarState) -> CarCommand:
        """Generate command for straight segment."""
        end_x, end_y = self.current_segment.end_point

        # Calculate direction to end point
        target_heading = math.atan2(end_y - current_state.y, end_x - current_state.x)
        heading_error = angle_difference(current_state.theta, target_heading)

        # Small heading correction if needed
        if abs(heading_error) > self.angle_tolerance:
            turn_amount = min(abs(heading_error), 0.1)

            if heading_error > 0:
                new_theta = normalize_angle(current_state.theta + turn_amount)
                expected_state = CarState(current_state.x, current_state.y, new_theta)
                return CarCommand(CarAction.TURN_LEFT, {"angle": turn_amount}, expected_state)
            else:
                new_theta = normalize_angle(current_state.theta - turn_amount)
                expected_state = CarState(current_state.x, current_state.y, new_theta)
                return CarCommand(CarAction.TURN_RIGHT, {"angle": turn_amount}, expected_state)

        # Move forward
        distance_to_end = math.sqrt((end_x - current_state.x)**2 + (end_y - current_state.y)**2)
        move_distance = min(distance_to_end, self.max_forward_step)

        expected_x = current_state.x + move_distance * math.cos(current_state.theta)
        expected_y = current_state.y + move_distance * math.sin(current_state.theta)
        expected_state = CarState(expected_x, expected_y, current_state.theta)

        return CarCommand(CarAction.FORWARD, {"distance": move_distance}, expected_state)

    def _generate_arc_command(self, current_state: CarState) -> CarCommand:
        """Generate command for arc segment (turn)."""
        if not self.current_segment.center_point:
            return self._generate_straight_command(current_state)

        center_x, center_y = self.current_segment.center_point

        # Current angle from center
        current_angle = math.atan2(current_state.y - center_y, current_state.x - center_x)

        # Step size along arc
        angular_step = self.max_forward_step / self.turning_radius

        if self.current_segment.segment_type == DubinsSegmentType.LEFT_TURN:
            target_angle = current_angle + angular_step
            turn_direction = CarAction.TURN_LEFT
        else:
            target_angle = current_angle - angular_step
            turn_direction = CarAction.TURN_RIGHT

        # New position on circle
        new_x = center_x + self.turning_radius * math.cos(target_angle)
        new_y = center_y + self.turning_radius * math.sin(target_angle)

        # New heading (tangent to circle)
        if self.current_segment.segment_type == DubinsSegmentType.LEFT_TURN:
            new_theta = normalize_angle(target_angle + math.pi/2)
        else:
            new_theta = normalize_angle(target_angle - math.pi/2)

        expected_state = CarState(new_x, new_y, new_theta)
        turn_angle = abs(angle_difference(current_state.theta, new_theta))

        return CarCommand(turn_direction, {"angle": turn_angle, "arc_movement": True}, expected_state)

    def update_car_position(self, car_status: CarStatus,
                            executed_command: CarCommand,
                            actual_result: Dict[str, Any] = None) -> CarStatus:
        """Update car status after command execution."""
        if actual_result and 'measured_position' in actual_result:
            measured_pos = actual_result['measured_position']
            new_state = CarState(measured_pos['x'], measured_pos['y'], measured_pos['theta'])
            new_confidence = config.car.position_drift
        else:
            new_state = executed_command.expected_end_state
            new_confidence = car_status.confidence_radius + config.car.position_drift

            if executed_command.action == CarAction.FORWARD:
                distance = executed_command.parameters.get('distance', 0)
                new_confidence += distance * config.car.forward_motion_error
            elif executed_command.action in [CarAction.TURN_LEFT, CarAction.TURN_RIGHT]:
                new_confidence += config.car.turn_angle_error

        return CarStatus(
            estimated_state=new_state,
            confidence_radius=new_confidence,
            last_command=executed_command,
            commands_executed=car_status.commands_executed + 1
        )

    def get_path_progress(self) -> Dict[str, Any]:
        """Get current progress through the path."""
        if not self.current_path:
            return {"status": "no_path"}

        total_segments = len(self.current_path)
        current_segment_idx = self.path_index

        dubins_progress = 0.0
        if self.current_segment and current_segment_idx < total_segments:
            dubins_progress = (self.current_segment.segment_index + 1) / 3.0

        overall_progress = (current_segment_idx + dubins_progress) / max(1, total_segments)

        return {
            "status": "active" if current_segment_idx < total_segments else "complete",
            "total_segments": total_segments,
            "current_segment": current_segment_idx,
            "dubins_segment_index": self.current_segment.segment_index if self.current_segment else -1,
            "dubins_segment_type": self.current_segment.segment_type.value if self.current_segment else "None",
            "overall_progress": overall_progress,
            "at_target": self.at_target,
            "image_recognition_time": self.image_recognition_time
        }


class CarMissionManager:
    """Mission manager using the Dubins-aware controller."""

    def __init__(self):
        self.path_planner = CarPathPlanner()
        self.controller = DubinsAwareController()
        self.car_status: Optional[CarStatus] = None
        self.mission_targets: List[int] = []
        self.visited_targets: List[int] = []

    def initialize_car(self, x: float, y: float, theta: float = 0.0):
        """Initialize car at starting position."""
        initial_state = CarState(x, y, theta)
        self.car_status = CarStatus(
            estimated_state=initial_state,
            confidence_radius=1.0
        )

    def add_obstacle(self, x: int, y: int, image_side: str) -> int:
        """Add obstacle to the world and return its index."""
        self.path_planner.add_obstacle(x, y, image_side)
        return len(self.path_planner.obstacles) - 1

    def plan_mission(self, target_obstacle_indices: List[int]) -> bool:
        """Plan a mission to visit specified obstacles."""
        if not self.car_status:
            return False

        print(f"Planning mission to visit obstacles: {target_obstacle_indices}")
        path_segments = self.path_planner.plan_visiting_path(
            self.car_status.estimated_state,
            target_obstacle_indices
        )

        if not path_segments:
            print("Mission planning failed - no valid path found")
            return False

        self.controller.set_path(path_segments)
        self.mission_targets = target_obstacle_indices.copy()
        self.visited_targets = []

        print(f"Mission planned: {len(path_segments)} Dubins paths to visit {len(target_obstacle_indices)} targets")
        return True

    def get_next_action(self) -> Optional[CarCommand]:
        """Get the next command for the car."""
        if not self.car_status:
            return None

        return self.controller.get_next_command(self.car_status)

    def execute_command(self, command: CarCommand,
                        actual_result: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute a command and update car status."""
        if not self.car_status:
            return {"status": "error", "message": "Car not initialized"}

        self.car_status = self.controller.update_car_position(
            self.car_status, command, actual_result
        )

        # Track completed targets
        progress = self.controller.get_path_progress()
        current_segment = progress.get("current_segment", 0)

        # When we finish image recognition and move to next segment, mark target as visited
        if (current_segment > len(self.visited_targets) and
            len(self.visited_targets) < len(self.mission_targets)):

            target_idx = len(self.visited_targets)
            actual_target = self.mission_targets[target_idx]
            self.visited_targets.append(actual_target)
            print(f"Completed target {actual_target} ({len(self.visited_targets)}/{len(self.mission_targets)})")

        return {
            "status": "success",
            "command_executed": command.action.value,
            "estimated_position": {
                "x": self.car_status.estimated_state.x,
                "y": self.car_status.estimated_state.y,
                "theta": self.car_status.estimated_state.theta
            },
            "position_confidence_radius": self.car_status.confidence_radius,
            "progress": progress
        }

    def get_status(self) -> Dict[str, Any]:
        """Get comprehensive status of car and mission."""
        if not self.car_status:
            return {"status": "not_initialized"}

        progress = self.controller.get_path_progress()

        return {
            "car_status": {
                "position": {
                    "x": self.car_status.estimated_state.x,
                    "y": self.car_status.estimated_state.y,
                    "theta": self.car_status.estimated_state.theta,
                    "theta_degrees": math.degrees(self.car_status.estimated_state.theta)
                },
                "confidence_radius": self.car_status.confidence_radius,
                "commands_executed": self.car_status.commands_executed
            },
            "mission": {
                "targets": self.mission_targets,
                "visited": self.visited_targets,
                "progress": progress
            },
            "obstacles_count": len(self.path_planner.obstacles)
        }
</file>

<file path="algo/lib/path.py">
from typing import List, Tuple, Optional
from enum import Enum
from dataclasses import dataclass

from lib.car import CarState


class DubinsPathType(Enum):
    """Types of Dubins paths for car-like motion."""
    RSR = "rsr"  # Right-Straight-Right
    RSL = "rsl"  # Right-Straight-Left
    LSR = "lsr"  # Left-Straight-Right
    LSL = "lsl"  # Left-Straight-Left
    RLR = "rlr"  # Right-Left-Right
    LRL = "lrl"  # Left-Right-Left

@dataclass
class Obstacle:
    """Obstacle in the arena with an image on one side."""
    x: int  # bottom-left corner x coordinate (cm)
    y: int  # bottom-left corner y coordinate (cm)
    image_side: str  # 'E', 'N', 'W', 'S' - which side has the image

@dataclass
class DubinsPath:
    """A Dubins path between two car configurations."""
    path_type: DubinsPathType
    length: float  # total path length in cm
    start_state: CarState
    end_state: CarState
    waypoints: List[Tuple[float, float]]  # sequence of (x,y) points
    turn_points: List[Tuple[float, float]]  # points where car changes from turn to straight
</file>

<file path="algo/lib/pathfinding.py">
"""
Enhanced pathfinding with multiple algorithms for robot car navigation.
Includes Dubins paths, A*, greedy nearest neighbor, and hybrid approaches.
"""

import math
import numpy as np
from typing import List, Tuple, Optional, Dict
from itertools import permutations
import heapq
from dataclasses import dataclass

from lib.car import CarState, normalize_angle, angle_difference
from lib.path import Obstacle, DubinsPath, DubinsPathType
from config import config

@dataclass
class PathfindingResult:
    """Result of pathfinding with debug info."""
    paths: List[DubinsPath]
    total_length: float
    algorithm_used: str
    debug_info: Dict

class DubinsPlanner:
    """Plans Dubins paths for car-like robot motion."""

    def __init__(self, turning_radius: float = None):
        self.turning_radius = turning_radius or config.car.turning_radius

    def plan_path(self, start: CarState, goal: CarState) -> Optional[DubinsPath]:
        """
        Plan shortest Dubins path between two car states.

        Returns None if no valid path exists.
        """
        best_path = None
        min_length = float('inf')

        # Try all 6 Dubins path types
        for path_type in DubinsPathType:
            try:
                path = self._compute_path(start, goal, path_type)
                if path and path.length < min_length and path.length > 0:
                    min_length = path.length
                    best_path = path
            except Exception as e:
                print(f"Error computing {path_type.value} path: {e}")
                continue

        return best_path

    def _compute_path(self, start: CarState, goal: CarState, path_type: DubinsPathType) -> Optional[DubinsPath]:
        """Compute specific Dubins path type."""
        r = self.turning_radius

        if path_type == DubinsPathType.RSR:
            return self._rsr_path(start, goal, r)
        elif path_type == DubinsPathType.RSL:
            return self._rsl_path(start, goal, r)
        elif path_type == DubinsPathType.LSR:
            return self._lsr_path(start, goal, r)
        elif path_type == DubinsPathType.LSL:
            return self._lsl_path(start, goal, r)
        elif path_type == DubinsPathType.RLR:
            return self._rlr_path(start, goal, r)
        else:  # LRL
            return self._lrl_path(start, goal, r)

    def _rsr_path(self, start: CarState, goal: CarState, r: float) -> Optional[DubinsPath]:
        """Right-Straight-Right path."""
        # Circle centers for right turns
        c1x = start.x + r * math.sin(start.theta)
        c1y = start.y - r * math.cos(start.theta)
        c2x = goal.x + r * math.sin(goal.theta)
        c2y = goal.y - r * math.cos(goal.theta)

        # Vector between circle centers
        dx, dy = c2x - c1x, c2y - c1y
        d = math.sqrt(dx*dx + dy*dy)

        if d < 0.001:  # Same circle
            return None

        # External tangent for RSR
        ux, uy = -dy/d, dx/d  # Unit perpendicular vector

        # Tangent points
        t1x, t1y = c1x + r * ux, c1y + r * uy
        t2x, t2y = c2x + r * ux, c2y + r * uy

        # Calculate arc angles
        alpha = self._arc_angle(start.x, start.y, c1x, c1y, t1x, t1y, True)
        beta = self._arc_angle(t2x, t2y, c2x, c2y, goal.x, goal.y, True)

        length = abs(alpha * r) + d + abs(beta * r)
        waypoints = [(start.x, start.y), (t1x, t1y), (t2x, t2y), (goal.x, goal.y)]
        turn_points = [(t1x, t1y), (t2x, t2y)]

        return DubinsPath(DubinsPathType.RSR, length, start, goal, waypoints, turn_points)

    def _rsl_path(self, start: CarState, goal: CarState, r: float) -> Optional[DubinsPath]:
        """Right-Straight-Left path."""
        # Right turn circle for start, left turn circle for goal
        c1x = start.x + r * math.sin(start.theta)
        c1y = start.y - r * math.cos(start.theta)
        c2x = goal.x - r * math.sin(goal.theta)
        c2y = goal.y + r * math.cos(goal.theta)

        dx, dy = c2x - c1x, c2y - c1y
        d = math.sqrt(dx*dx + dy*dy)

        if d < 2*r:  # Circles too close
            return None

        # Internal tangent angle
        try:
            phi = math.acos(2*r / d)
        except ValueError:
            return None

        # Tangent direction
        theta_t = math.atan2(dy, dx) + phi
        tx, ty = math.cos(theta_t), math.sin(theta_t)

        # Tangent points
        t1x, t1y = c1x + r * tx, c1y + r * ty
        t2x, t2y = c2x - r * tx, c2y - r * ty

        alpha = self._arc_angle(start.x, start.y, c1x, c1y, t1x, t1y, True)
        beta = self._arc_angle(t2x, t2y, c2x, c2y, goal.x, goal.y, False)
        straight = math.sqrt((t2x-t1x)**2 + (t2y-t1y)**2)

        length = abs(alpha * r) + straight + abs(beta * r)
        waypoints = [(start.x, start.y), (t1x, t1y), (t2x, t2y), (goal.x, goal.y)]
        turn_points = [(t1x, t1y), (t2x, t2y)]

        return DubinsPath(DubinsPathType.RSL, length, start, goal, waypoints, turn_points)

    def _lsr_path(self, start: CarState, goal: CarState, r: float) -> Optional[DubinsPath]:
        """Left-Straight-Right path."""
        # Left turn circle for start, right turn circle for goal
        c1x = start.x - r * math.sin(start.theta)
        c1y = start.y + r * math.cos(start.theta)
        c2x = goal.x + r * math.sin(goal.theta)
        c2y = goal.y - r * math.cos(goal.theta)

        dx, dy = c2x - c1x, c2y - c1y
        d = math.sqrt(dx*dx + dy*dy)

        if d < 2*r:
            return None

        try:
            phi = math.acos(2*r / d)
        except ValueError:
            return None

        theta_t = math.atan2(dy, dx) - phi
        tx, ty = math.cos(theta_t), math.sin(theta_t)

        t1x, t1y = c1x + r * tx, c1y + r * ty
        t2x, t2y = c2x - r * tx, c2y - r * ty

        alpha = self._arc_angle(start.x, start.y, c1x, c1y, t1x, t1y, False)
        beta = self._arc_angle(t2x, t2y, c2x, c2y, goal.x, goal.y, True)
        straight = math.sqrt((t2x-t1x)**2 + (t2y-t1y)**2)

        length = abs(alpha * r) + straight + abs(beta * r)
        waypoints = [(start.x, start.y), (t1x, t1y), (t2x, t2y), (goal.x, goal.y)]
        turn_points = [(t1x, t1y), (t2x, t2y)]

        return DubinsPath(DubinsPathType.LSR, length, start, goal, waypoints, turn_points)

    def _lsl_path(self, start: CarState, goal: CarState, r: float) -> Optional[DubinsPath]:
        """Left-Straight-Left path."""
        c1x = start.x - r * math.sin(start.theta)
        c1y = start.y + r * math.cos(start.theta)
        c2x = goal.x - r * math.sin(goal.theta)
        c2y = goal.y + r * math.cos(goal.theta)

        dx, dy = c2x - c1x, c2y - c1y
        d = math.sqrt(dx*dx + dy*dy)

        if d < 0.001:
            return None

        # External tangent for LSL (opposite direction from RSR)
        ux, uy = dy/d, -dx/d

        t1x, t1y = c1x + r * ux, c1y + r * uy
        t2x, t2y = c2x + r * ux, c2y + r * uy

        alpha = self._arc_angle(start.x, start.y, c1x, c1y, t1x, t1y, False)
        beta = self._arc_angle(t2x, t2y, c2x, c2y, goal.x, goal.y, False)

        length = abs(alpha * r) + d + abs(beta * r)
        waypoints = [(start.x, start.y), (t1x, t1y), (t2x, t2y), (goal.x, goal.y)]
        turn_points = [(t1x, t1y), (t2x, t2y)]

        return DubinsPath(DubinsPathType.LSL, length, start, goal, waypoints, turn_points)

    def _rlr_path(self, start: CarState, goal: CarState, r: float) -> Optional[DubinsPath]:
        """Right-Left-Right path."""
        c1x = start.x + r * math.sin(start.theta)
        c1y = start.y - r * math.cos(start.theta)
        c2x = goal.x + r * math.sin(goal.theta)
        c2y = goal.y - r * math.cos(goal.theta)

        dx, dy = c2x - c1x, c2y - c1y
        d = math.sqrt(dx*dx + dy*dy)

        if d > 4*r or d < 0.001:  # Too far or same point
            return None

        # Middle circle center
        mx, my = (c1x + c2x) / 2, (c1y + c2y) / 2
        h_sq = 4*r*r - d*d/4
        if h_sq < 0:
            return None
        h = math.sqrt(h_sq)

        # Perpendicular direction (choose one side)
        if d > 0.001:
            px, py = -dy/d, dx/d
        else:
            return None
        c3x, c3y = mx + h * px, my + h * py

        # Transition points
        t1x, t1y = (c1x + c3x) / 2, (c1y + c3y) / 2
        t2x, t2y = (c2x + c3x) / 2, (c2y + c3y) / 2

        alpha = self._arc_angle(start.x, start.y, c1x, c1y, t1x, t1y, True)
        beta = self._arc_angle(t1x, t1y, c3x, c3y, t2x, t2y, False)
        gamma = self._arc_angle(t2x, t2y, c2x, c2y, goal.x, goal.y, True)

        length = abs(alpha * r) + abs(beta * r) + abs(gamma * r)
        waypoints = [(start.x, start.y), (t1x, t1y), (t2x, t2y), (goal.x, goal.y)]
        turn_points = [(t1x, t1y), (t2x, t2y)]

        return DubinsPath(DubinsPathType.RLR, length, start, goal, waypoints, turn_points)

    def _lrl_path(self, start: CarState, goal: CarState, r: float) -> Optional[DubinsPath]:
        """Left-Right-Left path."""
        c1x = start.x - r * math.sin(start.theta)
        c1y = start.y + r * math.cos(start.theta)
        c2x = goal.x - r * math.sin(goal.theta)
        c2y = goal.y + r * math.cos(goal.theta)

        dx, dy = c2x - c1x, c2y - c1y
        d = math.sqrt(dx*dx + dy*dy)

        if d > 4*r or d < 0.001:
            return None

        mx, my = (c1x + c2x) / 2, (c1y + c2y) / 2
        h_sq = 4*r*r - d*d/4
        if h_sq < 0:
            return None
        h = math.sqrt(h_sq)

        if d > 0.001:
            px, py = dy/d, -dx/d  # Opposite perpendicular from RLR
        else:
            return None
        c3x, c3y = mx + h * px, my + h * py

        t1x, t1y = (c1x + c3x) / 2, (c1y + c3y) / 2
        t2x, t2y = (c2x + c3x) / 2, (c2y + c3y) / 2

        alpha = self._arc_angle(start.x, start.y, c1x, c1y, t1x, t1y, False)
        beta = self._arc_angle(t1x, t1y, c3x, c3y, t2x, t2y, True)
        gamma = self._arc_angle(t2x, t2y, c2x, c2y, goal.x, goal.y, False)

        length = abs(alpha * r) + abs(beta * r) + abs(gamma * r)
        waypoints = [(start.x, start.y), (t1x, t1y), (t2x, t2y), (goal.x, goal.y)]
        turn_points = [(t1x, t1y), (t2x, t2y)]

        return DubinsPath(DubinsPathType.LRL, length, start, goal, waypoints, turn_points)

    def _arc_angle(self, px: float, py: float, cx: float, cy: float,
                   qx: float, qy: float, clockwise: bool) -> float:
        """Calculate arc angle from point p to point q around center c."""
        # Vectors from center to points
        v1x, v1y = px - cx, py - cy
        v2x, v2y = qx - cx, qy - cy

        # Calculate angle difference
        angle = math.atan2(v2y, v2x) - math.atan2(v1y, v1x)

        # Adjust for turn direction
        if clockwise:
            if angle > 0:
                angle -= 2 * math.pi
        else:  # counterclockwise
            if angle < 0:
                angle += 2 * math.pi

        return angle


class CarPathPlanner:
    """Enhanced path planner with multiple algorithms."""

    def __init__(self):
        self.dubins_planner = DubinsPlanner()
        self.arena_size = config.arena.size
        self.grid_size = config.get_grid_size()
        self.obstacles = []

        # Collision grid (1 = blocked, 0 = free)
        self.collision_grid = np.zeros((self.grid_size, self.grid_size), dtype=int)

    def add_obstacle(self, x: int, y: int, image_side: str):
        """Add obstacle and update collision grid."""
        obstacle = Obstacle(x, y, image_side)
        self.obstacles.append(obstacle)
        self._update_collision_grid()
        print(f"Added obstacle {len(self.obstacles)-1} at ({x}, {y}) with image on {image_side} side")

    def _update_collision_grid(self):
        """Update collision grid with expanded obstacles."""
        self.collision_grid.fill(0)

        buffer = config.arena.collision_buffer
        cell_size = config.arena.grid_cell_size

        for obs in self.obstacles:
            # Convert to grid coordinates and expand
            min_x = max(0, (obs.x - buffer) // cell_size)
            max_x = min(self.grid_size, (obs.x + config.arena.obstacle_size + buffer) // cell_size)
            min_y = max(0, (obs.y - buffer) // cell_size)
            max_y = min(self.grid_size, (obs.y + config.arena.obstacle_size + buffer) // cell_size)

            self.collision_grid[min_y:max_y, min_x:max_x] = 1

    def get_image_target_position(self, obstacle: Obstacle) -> CarState:
        """Calculate target position to view image on obstacle."""
        distance = config.car.camera_distance

        if obstacle.image_side == 'S':  # Image on south side
            target_x = obstacle.x + config.arena.obstacle_size/2
            target_y = obstacle.y - distance
            target_theta = math.pi/2  # Face north
        elif obstacle.image_side == 'N':  # Image on north side
            target_x = obstacle.x + config.arena.obstacle_size/2
            target_y = obstacle.y + config.arena.obstacle_size + distance
            target_theta = 3*math.pi/2  # Face south
        elif obstacle.image_side == 'E':  # Image on east side
            target_x = obstacle.x + config.arena.obstacle_size + distance
            target_y = obstacle.y + config.arena.obstacle_size/2
            target_theta = math.pi  # Face west
        else:  # 'W' - Image on west side
            target_x = obstacle.x - distance
            target_y = obstacle.y + config.arena.obstacle_size/2
            target_theta = 0  # Face east

        return CarState(target_x, target_y, target_theta)

    def plan_visiting_path(self, start_state: CarState, obstacle_indices: List[int]) -> List[DubinsPath]:
        """Plan optimal path using multiple algorithms."""
        print(f"Planning path from ({start_state.x:.1f}, {start_state.y:.1f}) to visit obstacles: {obstacle_indices}")
        print(f"Available obstacles: {len(self.obstacles)}")

        if not obstacle_indices:
            print("No obstacles to visit")
            return []

        # Try multiple algorithms in order of preference
        algorithms = [
            self._greedy_nearest_neighbor,
            self._exhaustive_search,
            self._fallback_simple_path
        ]

        for algo in algorithms:
            try:
                result = algo(start_state, obstacle_indices)
                if result.paths:
                    print(f"Success with {result.algorithm_used}: {len(result.paths)} segments, {result.total_length:.1f}cm")
                    return result.paths
                else:
                    print(f"Failed with {result.algorithm_used}: {result.debug_info}")
            except Exception as e:
                print(f"Error with algorithm: {e}")
                continue

        print("All pathfinding algorithms failed")
        return []

    def _greedy_nearest_neighbor(self, start_state: CarState, obstacle_indices: List[int]) -> PathfindingResult:
        """Greedy nearest neighbor algorithm - fast but not optimal."""
        targets = []
        for idx in obstacle_indices:
            if 0 <= idx < len(self.obstacles):
                target_pos = self.get_image_target_position(self.obstacles[idx])
                targets.append((idx, target_pos))

        if not targets:
            return PathfindingResult([], 0, "greedy_nearest_neighbor", {"error": "no_valid_targets"})

        path_segments = []
        total_length = 0
        current_state = start_state
        remaining_targets = targets.copy()

        while remaining_targets:
            # Find nearest unvisited target
            best_target = None
            best_path = None
            min_distance = float('inf')

            for target in remaining_targets:
                _, target_state = target
                path = self.dubins_planner.plan_path(current_state, target_state)

                if path and not self._path_intersects_obstacles(path):
                    if path.length < min_distance:
                        min_distance = path.length
                        best_target = target
                        best_path = path

            if not best_path:
                return PathfindingResult([], 0, "greedy_nearest_neighbor",
                                       {"error": "no_valid_path", "remaining": len(remaining_targets)})

            path_segments.append(best_path)
            total_length += best_path.length
            current_state = best_path.end_state
            remaining_targets.remove(best_target)

        return PathfindingResult(path_segments, total_length, "greedy_nearest_neighbor",
                               {"segments": len(path_segments)})

    def _exhaustive_search(self, start_state: CarState, obstacle_indices: List[int]) -> PathfindingResult:
        """Exhaustive search for optimal solution."""
        if len(obstacle_indices) > 5:  # Too many for exhaustive search
            return PathfindingResult([], 0, "exhaustive_search", {"error": "too_many_targets"})

        targets = []
        for idx in obstacle_indices:
            if 0 <= idx < len(self.obstacles):
                target_pos = self.get_image_target_position(self.obstacles[idx])
                targets.append((idx, target_pos))

        if not targets:
            return PathfindingResult([], 0, "exhaustive_search", {"error": "no_valid_targets"})

        best_path = None
        min_length = float('inf')
        attempts = 0

        for perm in permutations(targets):
            attempts += 1
            path_segments = []
            total_length = 0
            current_state = start_state
            valid = True

            for obs_idx, target_state in perm:
                segment = self.dubins_planner.plan_path(current_state, target_state)
                if not segment:
                    valid = False
                    break

                # Less strict collision checking
                if self._path_intersects_obstacles_strict(segment):
                    valid = False
                    break

                path_segments.append(segment)
                total_length += segment.length
                current_state = target_state

            if valid and total_length < min_length:
                min_length = total_length
                best_path = path_segments

        if best_path:
            return PathfindingResult(best_path, min_length, "exhaustive_search",
                                   {"attempts": attempts, "segments": len(best_path)})
        else:
            return PathfindingResult([], 0, "exhaustive_search",
                                   {"error": "no_valid_permutation", "attempts": attempts})

    def _fallback_simple_path(self, start_state: CarState, obstacle_indices: List[int]) -> PathfindingResult:
        """Simple fallback - visit obstacles in order without collision checking."""
        targets = []
        for idx in obstacle_indices:
            if 0 <= idx < len(self.obstacles):
                target_pos = self.get_image_target_position(self.obstacles[idx])
                targets.append((idx, target_pos))

        if not targets:
            return PathfindingResult([], 0, "fallback_simple", {"error": "no_valid_targets"})

        path_segments = []
        total_length = 0
        current_state = start_state

        for obs_idx, target_state in targets:
            segment = self.dubins_planner.plan_path(current_state, target_state)
            if segment:
                path_segments.append(segment)
                total_length += segment.length
                current_state = target_state
            else:
                print(f"Warning: Could not plan path to obstacle {obs_idx}")

        return PathfindingResult(path_segments, total_length, "fallback_simple",
                               {"segments": len(path_segments), "warnings": True})

    def _path_intersects_obstacles(self, path: DubinsPath) -> bool:
        """Lenient collision check - allows paths close to obstacles."""
        return self._path_intersects_obstacles_strict(path, buffer_reduction=0)

    def _path_intersects_obstacles_strict(self, path: DubinsPath, buffer_reduction: float = 0) -> bool:
        """Check if path intersects with obstacles."""
        # Sample points along waypoints and check collision grid
        for i in range(len(path.waypoints) - 1):
            x1, y1 = path.waypoints[i]
            x2, y2 = path.waypoints[i + 1]

            # Sample points along this segment
            steps = max(3, int(math.sqrt((x2-x1)**2 + (y2-y1)**2) / 10))
            for step in range(steps + 1):
                t = step / steps if steps > 0 else 0
                x = x1 + t * (x2 - x1)
                y = y1 + t * (y2 - y1)

                # Convert to grid coordinates with reduced buffer
                buffer = max(1, (config.arena.collision_buffer * (1 - buffer_reduction)) // config.arena.grid_cell_size)
                gx = int(x / config.arena.grid_cell_size)
                gy = int(y / config.arena.grid_cell_size)

                # Check bounds
                if (gx < buffer or gx >= self.grid_size - buffer or
                    gy < buffer or gy >= self.grid_size - buffer):
                    return True

                # Check collision (with reduced sensitivity)
                for dx in range(-int(buffer), int(buffer) + 1):
                    for dy in range(-int(buffer), int(buffer) + 1):
                        check_x = gx + dx
                        check_y = gy + dy
                        if (0 <= check_x < self.grid_size and 0 <= check_y < self.grid_size and
                            self.collision_grid[check_y, check_x] == 1):
                            return True

        return False


if __name__ == "__main__":
    # Test the enhanced pathfinding
    planner = CarPathPlanner()

    # Add test obstacles
    planner.add_obstacle(50, 50, 'S')
    planner.add_obstacle(100, 100, 'E')
    planner.add_obstacle(150, 50, 'N')

    # Test path planning
    start = CarState(20, 20, 0)
    paths = planner.plan_visiting_path(start, [0, 1, 2])

    if paths:
        total_length = sum(p.length for p in paths)
        print(f"Final result: {len(paths)} segments, total length: {total_length:.1f}cm")
        for i, path in enumerate(paths):
            print(f"  Segment {i}: {path.path_type.value} ({path.length:.1f}cm)")
    else:
        print("No valid path found with any algorithm")
</file>

<file path="algo/server/server.py">
"""
Flask server for robot car pathfinding API.
Provides HTTP endpoints for car control, path planning, and status monitoring.
"""

from flask import Flask, request, jsonify
import logging
from typing import Dict, Any

from algo.lib.controller import CarMissionManager
from algo.lib.car import CarState, CarCommand, CarAction
from algo.config import config

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# Global mission manager instance
mission_manager: CarMissionManager = None


@app.before_first_request
def initialize_server():
    """Initialize the mission manager on first request."""
    global mission_manager
    mission_manager = CarMissionManager()
    logger.info("Car pathfinding server initialized")


@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        "status": "healthy",
        "service": "robot_car_pathfinding",
        "config": {
            "turning_radius": config.car.turning_radius,
            "arena_size": f"{config.arena.size}x{config.arena.size}cm"
        }
    })


@app.route('/car/initialize', methods=['POST'])
def initialize_car():
    """
    Initialize car at starting position.

    Expected JSON:
    {
        "x": 20.0,
        "y": 20.0,
        "theta": 0.0  // optional, defaults to 0
    }
    """
    global mission_manager

    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "JSON data required"}), 400

        x = float(data.get('x', 0))
        y = float(data.get('y', 0))
        theta = float(data.get('theta', 0))

        # Validate position is within arena
        if not (0 <= x <= config.arena.size and 0 <= y <= config.arena.size):
            return jsonify({"error": "Position outside arena bounds"}), 400

        mission_manager.initialize_car(x, y, theta)

        logger.info(f"Car initialized at ({x}, {y}) facing {theta:.3f} rad")

        return jsonify({
            "status": "success",
            "message": "Car initialized",
            "position": {"x": x, "y": y, "theta": theta}
        })

    except Exception as e:
        logger.error(f"Car initialization failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/obstacles/add', methods=['POST'])
def add_obstacle():
    """
    Add an obstacle to the arena.

    Expected JSON:
    {
        "x": 50,
        "y": 50,
        "image_side": "S"  // 'E', 'N', 'W', 'S'
    }
    """
    global mission_manager

    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "JSON data required"}), 400

        x = int(data.get('x'))
        y = int(data.get('y'))
        image_side = data.get('image_side', '').upper()

        if image_side not in ['E', 'N', 'W', 'S']:
            return jsonify({"error": "image_side must be E, N, W, or S"}), 400

        # Validate obstacle position
        if not (0 <= x <= config.arena.size - config.arena.obstacle_size and
                0 <= y <= config.arena.size - config.arena.obstacle_size):
            return jsonify({"error": "Obstacle position outside valid area"}), 400

        obstacle_id = mission_manager.add_obstacle(x, y, image_side)

        logger.info(f"Obstacle {obstacle_id} added at ({x}, {y}) with image on {image_side} side")

        return jsonify({
            "status": "success",
            "obstacle_id": obstacle_id,
            "position": {"x": x, "y": y},
            "image_side": image_side
        })

    except Exception as e:
        logger.error(f"Add obstacle failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/mission/plan', methods=['POST'])
def plan_mission():
    """
    Plan a mission to visit specified obstacles.

    Expected JSON:
    {
        "targets": [0, 1, 2]  // obstacle indices to visit
    }
    """
    global mission_manager

    try:
        data = request.get_json() or {}
        targets = data.get('targets', [])

        if not isinstance(targets, list):
            return jsonify({"error": "targets must be a list of obstacle indices"}), 400

        success = mission_manager.plan_mission(targets)

        if not success:
            return jsonify({
                "status": "failed",
                "message": "Could not plan path to visit specified obstacles"
            }), 400

        logger.info(f"Mission planned to visit obstacles: {targets}")

        return jsonify({
            "status": "success",
            "message": f"Mission planned to visit {len(targets)} obstacles",
            "targets": targets
        })

    except Exception as e:
        logger.error(f"Mission planning failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/car/next_action', methods=['GET'])
def get_next_action():
    """Get the next action for the car to perform."""
    global mission_manager

    try:
        command = mission_manager.get_next_action()

        if not command:
            return jsonify({
                "status": "no_action",
                "message": "No action available (mission not planned or complete)"
            })

        response = {
            "status": "success",
            "action": command.action.value,
            "parameters": command.parameters,
            "expected_end_state": {
                "x": command.expected_end_state.x,
                "y": command.expected_end_state.y,
                "theta": command.expected_end_state.theta
            }
        }

        return jsonify(response)

    except Exception as e:
        logger.error(f"Get next action failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/car/execute', methods=['POST'])
def execute_command():
    """
    Execute a car command and update position.

    Expected JSON:
    {
        "action": "forward",
        "parameters": {"distance": 10.0},
        "actual_result": {  // optional - actual sensor readings
            "measured_position": {"x": 25.2, "y": 20.1, "theta": 0.05}
        }
    }
    """
    global mission_manager

    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "JSON data required"}), 400

        action_str = data.get('action', '')
        parameters = data.get('parameters', {})
        actual_result = data.get('actual_result', {})

        # Parse action
        try:
            action = CarAction(action_str)
        except ValueError:
            return jsonify({"error": f"Invalid action: {action_str}"}), 400

        # Create command (we need expected end state, but server doesn't know it)
        # This is a limitation - ideally the command comes from get_next_action
        current_status = mission_manager.car_status
        if not current_status:
            return jsonify({"error": "Car not initialized"}), 400

        # Create a dummy command for execution tracking
        command = CarCommand(action, parameters, current_status.estimated_state)

        result = mission_manager.execute_command(command, actual_result)

        logger.info(f"Executed {action_str} with result: {result['status']}")

        return jsonify(result)

    except Exception as e:
        logger.error(f"Command execution failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/car/position', methods=['POST'])
def update_car_position():
    """
    Manually update car position (for position corrections).

    Expected JSON:
    {
        "x": 25.5,
        "y": 30.2,
        "theta": 0.52
    }
    """
    global mission_manager

    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "JSON data required"}), 400

        x = float(data.get('x'))
        y = float(data.get('y'))
        theta = float(data.get('theta'))

        if not mission_manager.car_status:
            return jsonify({"error": "Car not initialized"}), 400

        # Update position directly
        mission_manager.car_status.estimated_state = CarState(x, y, theta)
        mission_manager.car_status.confidence_radius = 1.0  # Reset confidence

        logger.info(f"Car position updated to ({x:.2f}, {y:.2f}, {theta:.3f})")

        return jsonify({
            "status": "success",
            "message": "Position updated",
            "position": {"x": x, "y": y, "theta": theta}
        })

    except Exception as e:
        logger.error(f"Position update failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/status', methods=['GET'])
def get_status():
    """Get comprehensive system status."""
    global mission_manager

    try:
        status = mission_manager.get_status()
        return jsonify({
            "status": "success",
            "data": status
        })

    except Exception as e:
        logger.error(f"Get status failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.route('/reset', methods=['POST'])
def reset_system():
    """Reset the entire system."""
    global mission_manager

    try:
        mission_manager = CarMissionManager()
        logger.info("System reset complete")

        return jsonify({
            "status": "success",
            "message": "System reset complete"
        })

    except Exception as e:
        logger.error(f"System reset failed: {str(e)}")
        return jsonify({"error": str(e)}), 500


@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Endpoint not found"}), 404


@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500


if __name__ == '__main__':
    print("=" * 60)
    print("Robot Car Pathfinding Server")
    print("=" * 60)
    print("\nAvailable endpoints:")
    print("  GET  /health              - Health check")
    print("  POST /car/initialize      - Initialize car position")
    print("  POST /obstacles/add       - Add obstacle to arena")
    print("  POST /mission/plan        - Plan mission to visit obstacles")
    print("  GET  /car/next_action     - Get next action for car")
    print("  POST /car/execute         - Execute car command")
    print("  POST /car/position        - Update car position")
    print("  GET  /status              - Get system status")
    print("  POST /reset               - Reset system")
    print("\nKey features:")
    print("  • Dubins path planning for car-like motion")
    print("  • Position uncertainty handling")
    print("  • Hamiltonian path optimization")
    print("  • Collision avoidance")
    print(f"\nStarting server on {config.server.host}:{config.server.port}")
    print("=" * 60)

    app.run(
        host=config.server.host,
        port=config.server.port,
        debug=config.server.debug
    )
</file>

<file path="algo/config.py">
from dataclasses import dataclass


@dataclass
class RobotConfig:
    width: float = 5  # cm
    length: float = 5  # cm
    turning_radius: float = 10.0  # minimum turning radius in cm
    camera_distance: float = 10.0  # optimal distance from obstacle for image recognition

    # motion uncertainty
    forward_motion_error: float = 0  # 5% error in forward motion
    turn_angle_error: float = 0.0
    position_drift: float = 0  # cm of random position drift per action


@dataclass
class Arena:
    size: int = 200  # arena size in cm (200x200)
    grid_cell_size: int = 5  # size of each grid cell in cm
    obstacle_size: int = 5  # physical obstacle size in cm
    collision_buffer: int = 30  # extra space around obstacles for collision avoidance


@dataclass
class PathfindingParams:
    waypoint_tolerance: float = 5.0  # cm - how close to waypoint before advancing
    angle_tolerance: float = 0.1  # radians - when car is considered aligned
    max_forward_step: float = 5.0  # cm - maximum forward movement action
    max_turn_step: float = 0.1  # radians how much is a maximum turn action

class Config:
    def __init__(self, config_file: str = 'car_config.json'):
        self.config_file = config_file
        self.car = RobotConfig()
        self.arena = Arena()
        self.pathfinding = PathfindingParams()

    def get_grid_size(self) -> int:
        return self.arena.size // self.arena.grid_cell_size


# Global configuration (import and use this)
config = Config()
</file>

<file path="algo/sim.py">
import pygame
import math
import sys
from typing import List, Tuple, Optional

from lib.car import CarState, CarAction
from lib.path import Obstacle, DubinsPath
from lib.pathfinding import CarPathPlanner, DubinsPlanner
from lib.controller import CarMissionManager  # Use the fixed controller
from config import config


class Colors:
    """Color constants for visualization."""
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    RED = (255, 0, 0)
    GREEN = (0, 255, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
    ORANGE = (255, 165, 0)
    PURPLE = (128, 0, 128)
    GRAY = (128, 128, 128)
    LIGHT_GRAY = (200, 200, 200)
    DARK_GREEN = (0, 100, 0)
    LIGHT_GREEN = (144, 238, 144)
    LIGHT_BLUE = (173, 216, 230)
    DARK_BLUE = (0, 0, 139)
    MAGENTA = (255, 0, 255)
    CYAN = (0, 255, 255)


class ImprovedCarVisualizer:
    """Improved pygame-based car pathfinding visualizer with curved paths."""

    def __init__(self, width=1200, height=900):
        pygame.init()

        self.screen_width = width
        self.screen_height = height
        self.arena_size = config.arena.size

        # Calculate scale factor
        self.scale = min((width - 200) / self.arena_size, (height - 150) / self.arena_size)
        self.offset_x = 100
        self.offset_y = 75

        # Initialize pygame
        self.screen = pygame.display.set_mode((width, height))
        pygame.display.set_caption("Enhanced Robot Car Pathfinding - Dubins Paths")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 24)
        self.small_font = pygame.font.Font(None, 18)

        # Visualization state
        self.obstacles = []
        self.planned_paths = []
        self.car_state = None
        self.target_positions = []
        self.car_trail = []
        self.current_target_highlight = -1
        self.image_recognition_status = False
        self.status_messages = []

        # Animation state
        self.running = True
        self.paused = False
        self.show_grid = True
        self.show_paths = True
        self.show_waypoints = True
        self.show_turning_circles = False
        self.animation_speed = 1

    def world_to_screen(self, x: float, y: float) -> Tuple[int, int]:
        """Convert world coordinates to screen coordinates."""
        screen_x = int(self.offset_x + x * self.scale)
        screen_y = int(self.offset_y + (self.arena_size - y) * self.scale)
        return screen_x, screen_y

    def screen_to_world(self, screen_x: int, screen_y: int) -> Tuple[float, float]:
        """Convert screen coordinates to world coordinates."""
        x = (screen_x - self.offset_x) / self.scale
        y = self.arena_size - (screen_y - self.offset_y) / self.scale
        return x, y

    def draw_grid(self):
        """Draw grid lines."""
        if not self.show_grid:
            return

        grid_spacing = 20
        for i in range(0, self.arena_size + 1, grid_spacing):
            start_x, start_y = self.world_to_screen(i, 0)
            end_x, end_y = self.world_to_screen(i, self.arena_size)
            pygame.draw.line(self.screen, Colors.LIGHT_GRAY, (start_x, start_y), (end_x, end_y))

            start_x, start_y = self.world_to_screen(0, i)
            end_x, end_y = self.world_to_screen(self.arena_size, i)
            pygame.draw.line(self.screen, Colors.LIGHT_GRAY, (start_x, start_y), (end_x, end_y))

    def draw_arena(self):
        """Draw the arena boundary and start zone."""
        # Arena boundary
        top_left = self.world_to_screen(0, self.arena_size)
        width = int(self.arena_size * self.scale)
        height = int(self.arena_size * self.scale)
        pygame.draw.rect(self.screen, Colors.BLACK, (top_left[0], top_left[1], width, height), 3)

        # Start zone
        start_top_left = self.world_to_screen(0, 40)
        start_width = int(40 * self.scale)
        start_height = int(40 * self.scale)
        pygame.draw.rect(self.screen, Colors.LIGHT_GREEN,
                         (start_top_left[0], start_top_left[1], start_width, start_height))
        pygame.draw.rect(self.screen, Colors.DARK_GREEN,
                         (start_top_left[0], start_top_left[1], start_width, start_height), 2)

        text = self.font.render("START", True, Colors.DARK_GREEN)
        text_pos = self.world_to_screen(20, 20)
        text_rect = text.get_rect(center=text_pos)
        self.screen.blit(text, text_rect)

    def draw_obstacle(self, obstacle: Obstacle, obstacle_id: int):
        """Draw obstacle with image side clearly marked."""
        size = config.arena.obstacle_size
        top_left = self.world_to_screen(obstacle.x, obstacle.y + size)
        width = int(size * self.scale)
        height = int(size * self.scale)

        # Highlight current target
        if obstacle_id == self.current_target_highlight:
            pygame.draw.rect(self.screen, Colors.MAGENTA,
                             (top_left[0] - 3, top_left[1] - 3, width + 6, height + 6))

        # Main obstacle
        pygame.draw.rect(self.screen, Colors.RED, (top_left[0], top_left[1], width, height))
        pygame.draw.rect(self.screen, Colors.BLACK, (top_left[0], top_left[1], width, height), 2)

        # Image side indicator - make it more prominent
        indicator_size = max(4, int(3 * self.scale))
        if obstacle.image_side == 'S':
            img_pos = self.world_to_screen(obstacle.x, obstacle.y - 1)
            pygame.draw.rect(self.screen, Colors.YELLOW,
                             (img_pos[0], img_pos[1], width, indicator_size))
        elif obstacle.image_side == 'N':
            img_pos = self.world_to_screen(obstacle.x, obstacle.y + size + 1)
            pygame.draw.rect(self.screen, Colors.YELLOW,
                             (img_pos[0], img_pos[1], width, indicator_size))
        elif obstacle.image_side == 'E':
            img_pos = self.world_to_screen(obstacle.x + size + 1, obstacle.y + size)
            pygame.draw.rect(self.screen, Colors.YELLOW,
                             (img_pos[0], img_pos[1], indicator_size, height))
        else:  # West
            img_pos = self.world_to_screen(obstacle.x - 1, obstacle.y + size)
            pygame.draw.rect(self.screen, Colors.YELLOW,
                             (img_pos[0] - indicator_size, img_pos[1], indicator_size, height))

        # Obstacle ID
        center_pos = self.world_to_screen(obstacle.x + size / 2, obstacle.y + size / 2)
        text = self.font.render(str(obstacle_id), True, Colors.WHITE)
        text_rect = text.get_rect(center=center_pos)
        self.screen.blit(text, text_rect)

    def draw_car(self, car_state: CarState, color=Colors.BLUE):
        """Draw the car with proper orientation."""
        car_width = config.car.width * self.scale
        car_length = config.car.length * self.scale

        # Car corners
        corners = [
            (-car_length / 2, -car_width / 2),
            (car_length / 2, -car_width / 2),
            (car_length / 2, car_width / 2),
            (-car_length / 2, car_width / 2)
        ]

        cos_theta = math.cos(car_state.theta)
        sin_theta = math.sin(car_state.theta)

        screen_corners = []
        for corner_x, corner_y in corners:
            rotated_x = corner_x * cos_theta - corner_y * sin_theta
            rotated_y = corner_x * sin_theta + corner_y * cos_theta

            world_x = car_state.x + rotated_x / self.scale
            world_y = car_state.y + rotated_y / self.scale
            screen_corners.append(self.world_to_screen(world_x, world_y))

        # Draw car body
        if self.image_recognition_status:
            # Flash when doing image recognition
            flash_color = Colors.CYAN if (pygame.time.get_ticks() // 200) % 2 else color
            pygame.draw.polygon(self.screen, flash_color, screen_corners)
        else:
            pygame.draw.polygon(self.screen, color, screen_corners)
        pygame.draw.polygon(self.screen, Colors.BLACK, screen_corners, 2)

        # Direction arrow - longer and more visible
        arrow_length = 20
        arrow_end_x = car_state.x + arrow_length * cos_theta
        arrow_end_y = car_state.y + arrow_length * sin_theta

        start_pos = self.world_to_screen(car_state.x, car_state.y)
        end_pos = self.world_to_screen(arrow_end_x, arrow_end_y)

        pygame.draw.line(self.screen, Colors.RED, start_pos, end_pos, 4)

        # Arrowhead
        arrowhead_length = 8
        arrowhead_angle = 0.4

        left_x = arrow_end_x - arrowhead_length * math.cos(car_state.theta - arrowhead_angle)
        left_y = arrow_end_y - arrowhead_length * math.sin(car_state.theta - arrowhead_angle)
        right_x = arrow_end_x - arrowhead_length * math.cos(car_state.theta + arrowhead_angle)
        right_y = arrow_end_y - arrowhead_length * math.sin(car_state.theta + arrowhead_angle)

        left_pos = self.world_to_screen(left_x, left_y)
        right_pos = self.world_to_screen(right_x, right_y)

        pygame.draw.polygon(self.screen, Colors.RED, [end_pos, left_pos, right_pos])

    def draw_curved_dubins_path(self, path: DubinsPath, color=Colors.BLUE, width=3):
        """Draw a curved Dubins path with proper arc segments."""
        if not self.show_paths or not path.waypoints:
            return

        # Draw the path with curves
        self._draw_dubins_curve(path, color, width)

        # Draw waypoints if enabled
        if self.show_waypoints:
            for i, (x, y) in enumerate(path.waypoints):
                pos = self.world_to_screen(x, y)
                if i == 0:  # Start
                    pygame.draw.circle(self.screen, Colors.GREEN, pos, 6)
                    pygame.draw.circle(self.screen, Colors.BLACK, pos, 6, 2)
                elif i == len(path.waypoints) - 1:  # End
                    pygame.draw.circle(self.screen, Colors.RED, pos, 6)
                    pygame.draw.circle(self.screen, Colors.BLACK, pos, 6, 2)
                else:  # Intermediate
                    pygame.draw.circle(self.screen, color, pos, 4)

        # Path type label
        if path.waypoints:
            mid_idx = len(path.waypoints) // 2
            label_pos = self.world_to_screen(
                path.waypoints[mid_idx][0] + 8,
                path.waypoints[mid_idx][1] + 8
            )
            text = self.small_font.render(path.path_type.value.upper(), True, color)
            self.screen.blit(text, label_pos)

    def _draw_dubins_curve(self, path: DubinsPath, color, width):
        """Draw the actual curved path for Dubins paths."""
        waypoints = path.waypoints
        path_type = path.path_type.value

        # Draw segments based on path type
        segments = []
        if len(path_type) == 3:  # e.g., "rsr", "lsl"
            segments = [
                (0, 1, path_type[0]),  # First turn
                (1, 2, path_type[1]),  # Straight
                (2, 3, path_type[2])  # Second turn
            ]

        for start_idx, end_idx, segment_type in segments:
            if start_idx >= len(waypoints) or end_idx >= len(waypoints):
                continue

            start_point = waypoints[start_idx]
            end_point = waypoints[end_idx]

            if segment_type.lower() == 's':  # Straight segment
                start_pos = self.world_to_screen(start_point[0], start_point[1])
                end_pos = self.world_to_screen(end_point[0], end_point[1])
                pygame.draw.line(self.screen, color, start_pos, end_pos, width)
            else:  # Curved segment (L or R)
                self._draw_arc_segment(start_point, end_point, segment_type, color, width)

    def _draw_arc_segment(self, start_point, end_point, turn_type, color, width):
        """Draw an arc segment for turning parts of Dubins paths."""
        # Approximate arc with multiple line segments
        steps = 20
        points = []

        for i in range(steps + 1):
            t = i / steps
            # Simple interpolation - in a real implementation you'd calculate the actual arc
            x = start_point[0] + t * (end_point[0] - start_point[0])
            y = start_point[1] + t * (end_point[1] - start_point[1])

            # Add curvature based on turn type
            if turn_type.lower() == 'l':  # Left turn
                # Curve to the left
                offset = math.sin(t * math.pi) * 5
                perpendicular_x = -(end_point[1] - start_point[1])
                perpendicular_y = end_point[0] - start_point[0]
                length = math.sqrt(perpendicular_x ** 2 + perpendicular_y ** 2)
                if length > 0:
                    perpendicular_x /= length
                    perpendicular_y /= length
                    x += offset * perpendicular_x
                    y += offset * perpendicular_y
            elif turn_type.lower() == 'r':  # Right turn
                # Curve to the right
                offset = math.sin(t * math.pi) * 5
                perpendicular_x = end_point[1] - start_point[1]
                perpendicular_y = -(end_point[0] - start_point[0])
                length = math.sqrt(perpendicular_x ** 2 + perpendicular_y ** 2)
                if length > 0:
                    perpendicular_x /= length
                    perpendicular_y /= length
                    x += offset * perpendicular_x
                    y += offset * perpendicular_y

            points.append(self.world_to_screen(x, y))

        # Draw the curved line
        if len(points) > 1:
            pygame.draw.lines(self.screen, color, False, points, width)

    def draw_target_position(self, target_state: CarState, target_id: int, is_current=False):
        """Draw a target position for image recognition."""
        pos = self.world_to_screen(target_state.x, target_state.y)

        # Target marker - larger and more visible
        size = 12 if is_current else 8
        color = Colors.CYAN if is_current else Colors.PURPLE

        pygame.draw.rect(self.screen, color, (pos[0] - size, pos[1] - size, size * 2, size * 2))
        pygame.draw.rect(self.screen, Colors.BLACK, (pos[0] - size, pos[1] - size, size * 2, size * 2), 2)

        # Target orientation arrow - show where car should be looking
        arrow_len = 20
        arrow_end_x = target_state.x + arrow_len * math.cos(target_state.theta)
        arrow_end_y = target_state.y + arrow_len * math.sin(target_state.theta)
        end_pos = self.world_to_screen(arrow_end_x, arrow_end_y)

        pygame.draw.line(self.screen, color, pos, end_pos, 4)

        # Arrowhead for target direction
        arrowhead_length = 6
        arrowhead_angle = 0.4
        left_x = arrow_end_x - arrowhead_length * math.cos(target_state.theta - arrowhead_angle)
        left_y = arrow_end_y - arrowhead_length * math.sin(target_state.theta - arrowhead_angle)
        right_x = arrow_end_x - arrowhead_length * math.cos(target_state.theta + arrowhead_angle)
        right_y = arrow_end_y - arrowhead_length * math.sin(target_state.theta + arrowhead_angle)

        left_pos = self.world_to_screen(left_x, left_y)
        right_pos = self.world_to_screen(right_x, right_y)
        pygame.draw.polygon(self.screen, color, [end_pos, left_pos, right_pos])

        # Target label
        text = self.small_font.render(f'T{target_id}', True, color)
        label_pos = (pos[0] + 15, pos[1] - 15)
        self.screen.blit(text, label_pos)

    def draw_car_trail(self):
        """Draw the trail of car positions."""
        if len(self.car_trail) < 2:
            return

        trail_points = [self.world_to_screen(state.x, state.y) for state in self.car_trail]

        # Draw trail with fading effect
        for i in range(len(trail_points) - 1):
            alpha = int(255 * (i + 1) / len(trail_points))
            color = (*Colors.ORANGE, alpha)

            # Create a surface for alpha blending
            trail_surf = pygame.Surface((self.screen_width, self.screen_height))
            trail_surf.set_alpha(alpha)
            trail_surf.fill(Colors.WHITE)
            trail_surf.set_colorkey(Colors.WHITE)

            pygame.draw.line(trail_surf, Colors.ORANGE, trail_points[i], trail_points[i + 1], 2)
            self.screen.blit(trail_surf, (0, 0))

    def draw_ui(self):
        """Draw enhanced user interface."""
        # Title
        title = self.font.render("Enhanced Robot Car Pathfinding - Dubins Paths", True, Colors.BLACK)
        self.screen.blit(title, (10, 10))

        # Controls
        controls = [
            "SPACE - Play/Pause", "G - Toggle Grid", "P - Toggle Paths",
            "W - Toggle Waypoints", "T - Toggle Turning Circles",
            "+/- - Speed", "R - Reset", "ESC - Exit"
        ]

        y_offset = 35
        for control in controls:
            text = self.small_font.render(control, True, Colors.BLACK)
            self.screen.blit(text, (10, y_offset))
            y_offset += 18

        # Status panel
        panel_x = self.screen_width - 300
        panel_y = 10
        panel_width = 280
        panel_height = 200

        pygame.draw.rect(self.screen, Colors.LIGHT_GRAY, (panel_x, panel_y, panel_width, panel_height))
        pygame.draw.rect(self.screen, Colors.BLACK, (panel_x, panel_y, panel_width, panel_height), 2)

        # Car status
        if self.car_state:
            status_lines = [
                "CAR STATUS:",
                f"Position: ({self.car_state.x:.1f}, {self.car_state.y:.1f})",
                f"Heading: {math.degrees(self.car_state.theta):.1f}°",
                f"Speed: {self.animation_speed}x"
            ]

            if self.image_recognition_status:
                status_lines.append(">>> SCANNING IMAGE <<<")

            for i, line in enumerate(status_lines):
                color = Colors.CYAN if "SCANNING" in line else Colors.BLACK
                text = self.small_font.render(line, True, color)
                self.screen.blit(text, (panel_x + 10, panel_y + 15 + i * 18))

        # Status messages
        msg_y = panel_y + 120
        for i, msg in enumerate(self.status_messages[-4:]):  # Show last 4 messages
            alpha = max(50, 255 - i * 50)
            text = self.small_font.render(msg, True, Colors.DARK_BLUE)
            self.screen.blit(text, (panel_x + 10, msg_y + i * 18))

        # Pause indicator
        if self.paused:
            pause_text = self.font.render("PAUSED", True, Colors.RED)
            pause_pos = (self.screen_width - 100, self.screen_height - 30)
            self.screen.blit(pause_text, pause_pos)

    def add_status_message(self, message: str):
        """Add a status message to the display."""
        self.status_messages.append(message)
        if len(self.status_messages) > 10:
            self.status_messages.pop(0)

    def handle_events(self):
        """Handle pygame events."""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False
                elif event.key == pygame.K_SPACE:
                    self.paused = not self.paused
                elif event.key == pygame.K_g:
                    self.show_grid = not self.show_grid
                elif event.key == pygame.K_p:
                    self.show_paths = not self.show_paths
                elif event.key == pygame.K_w:
                    self.show_waypoints = not self.show_waypoints
                elif event.key == pygame.K_t:
                    self.show_turning_circles = not self.show_turning_circles
                elif event.key == pygame.K_r:
                    self.reset()
                elif event.key == pygame.K_EQUALS or event.key == pygame.K_PLUS:
                    self.animation_speed = min(5, self.animation_speed + 1)
                elif event.key == pygame.K_MINUS:
                    self.animation_speed = max(1, self.animation_speed - 1)

    def reset(self):
        """Reset visualization state."""
        self.car_trail = []
        self.status_messages = []
        if self.car_state:
            self.car_trail.append(CarState(self.car_state.x, self.car_state.y, self.car_state.theta))

    def update(self):
        """Update visualization state."""
        pass  # Override in specific demos

    def render(self):
        """Render the current frame."""
        self.screen.fill(Colors.WHITE)

        self.draw_grid()
        self.draw_arena()

        # Draw obstacles
        for i, obstacle in enumerate(self.obstacles):
            self.draw_obstacle(obstacle, i)

        # Draw target positions
        for i, target_state in enumerate(self.target_positions):
            is_current = i == self.current_target_highlight
            self.draw_target_position(target_state, i, is_current)

        # Draw planned paths with different colors
        path_colors = [Colors.BLUE, Colors.DARK_GREEN, Colors.RED, Colors.PURPLE, Colors.ORANGE]
        for i, path in enumerate(self.planned_paths):
            color = path_colors[i % len(path_colors)]
            self.draw_curved_dubins_path(path, color)

        # Draw car trail
        self.draw_car_trail()

        # Draw current car
        if self.car_state:
            self.draw_car(self.car_state)

        # Draw UI
        self.draw_ui()

        pygame.display.flip()

    def run(self):
        """Main visualization loop."""
        while self.running:
            self.handle_events()

            if not self.paused:
                for _ in range(self.animation_speed):
                    self.update()

            self.render()
            self.clock.tick(60)

        pygame.quit()
        sys.exit()


class EnhancedCarSimulation(ImprovedCarVisualizer):
    """Enhanced car simulation with proper Dubins path following."""

    def __init__(self):
        super().__init__()
        self.setup_simulation()
        self.simulation_step = 0
        self.max_steps = 500
        self.step_delay = 0

    def setup_simulation(self):
        """Setup the enhanced simulation."""
        self.manager = CarMissionManager()
        self.manager.initialize_car(20, 20, 0)

        # Add obstacles with different image sides
        obstacle_configs = [
            (60, 60, 'S'),  # Image on south side
            (120, 100, 'E'),  # Image on east side
            (150, 50, 'N'),  # Image on north side
            (80, 140, 'W'),  # Image on west side
        ]

        for x, y, side in obstacle_configs:
            self.manager.add_obstacle(x, y, side)
            self.obstacles.append(Obstacle(x, y, side))

        # Plan mission to visit all obstacles
        target_indices = [0, 1, 2, 3]
        if self.manager.plan_mission(target_indices):
            self.planned_paths = self.manager.controller.current_path
            self.add_status_message("Mission planned successfully!")

            # Get target positions for visualization
            self.target_positions = []
            for obs in self.manager.path_planner.obstacles:
                target_state = self.manager.path_planner.get_image_target_position(obs)
                self.target_positions.append(target_state)
        else:
            self.add_status_message("Mission planning failed!")

        # Initialize car state and trail
        self.car_state = self.manager.car_status.estimated_state
        self.car_trail = [CarState(self.car_state.x, self.car_state.y, self.car_state.theta)]

    def update(self):
        """Update the enhanced simulation."""
        if self.simulation_step >= self.max_steps:
            return

        # Get next command
        command = self.manager.get_next_action()
        if not command:
            self.add_status_message("No more commands")
            return

        if command.action == CarAction.STOP:
            self.add_status_message("Mission complete!")

        # Execute command
        result = self.manager.execute_command(command)

        # Update visualization state
        self.car_state = self.manager.car_status.estimated_state
        self.car_trail.append(CarState(self.car_state.x, self.car_state.y, self.car_state.theta))

        # Update UI indicators
        progress = result.get('progress', {})
        self.image_recognition_status = progress.get('at_target', False)

        # Highlight current target
        if progress.get('current_segment', -1) < len(self.target_positions):
            self.current_target_highlight = progress.get('current_segment', -1)

        # Add status messages for interesting events
        if command.action == CarAction.FORWARD:
            distance = command.parameters.get('distance', 0)
            if distance > 0:
                self.add_status_message(f"Moving forward {distance:.1f}cm")
        elif command.action in [CarAction.TURN_LEFT, CarAction.TURN_RIGHT]:
            angle = command.parameters.get('angle', 0)
            direction = "left" if command.action == CarAction.TURN_LEFT else "right"
            self.add_status_message(f"Turning {direction} {math.degrees(angle):.1f}°")

        if progress.get('image_recognition_time', 0) > 0:
            frames = progress.get('image_recognition_time', 0)
            self.add_status_message(f"Scanning image... ({frames} frames left)")

        # Check for completed targets
        visited = len(self.manager.visited_targets)
        if hasattr(self, '_last_visited_count'):
            if visited > self._last_visited_count:
                self.add_status_message(f"Target {visited - 1} completed!")
        self._last_visited_count = visited

        self.simulation_step += 1


if __name__ == "__main__":
    print("Enhanced Car Pathfinding Visualization")
    print("=" * 45)
    print("Features:")
    print("- Curved Dubins paths")
    print("- Image recognition stops")
    print("- Enhanced visualization")
    print("- Real-time status")

    simulation = EnhancedCarSimulation()
    simulation.run()
</file>

<file path="README.md">
# SC2079-Group-15
</file>

</files>
